[{"content":"Abstract A simple 4x3 buffered multiple which can easily be fit on a 46x16 stripboard. The schematics are based on the 1161 Buffered Multiple from Sam Battle (aka LOOK MUM NO COMPUTER).\nIntroduction Alright, this is a very simple yet absolutely essential module in a modular synth: the buffered multiple.\nWhy is it called multiple? Because it\u0026rsquo;s makes multiple signals out of one by replicating it. What does buffered mean? In contrast to a passive multiple which is basically a cable distributor, a buffered multiple not only replicates the signal on each of its outputs, it also buffers them in the sense that it decouples it from the original current source. This essentially means that you can feed in a high impedance signal (which effectively means its voltage would collapse when it\u0026rsquo;s drained too hard) and you get a low impedance one.\nThis is a 4x3 multiple, so it provides 4 inputs and 3 outputs for each input. The circuit is fairly simple and consists of four quadruple opamps (TL074). Three of the opamps of each TL074 are used to buffer the outputs and one is to drive the corresponding LED. I recommend bipolar LEDs which will light up in different colours depending on the polarity of the voltage. It\u0026rsquo;s very useful (and cool looking) when you buffer for example LFO signals, so that you can see when the voltage is positive or negative. Be aware that LEDs have a forward voltage of usually a little more than one 1V (depending on the type), so you won\u0026rsquo;t see a any light when the signal is lower than that.\nStripboard Layout Below is the stipboard layout which can also be split in half easily in case you are a Eurorack builder or only want to build a 2x3. You can simply solder a 5x2 pin-header on the top 5 stripes and a female connector on the second board, so that you can connect the two halves. This method can also be used to make a 8x3 multiple and so on ;)\nPDF version of the stripboard layout: Buffered multiple 4x3 stripboard v1 (PDF, 427KB)\nPanel I made a 5cm x 20cm panel which is a perfect fit for my taste. I use 2mm aluminium sheets with the following panel layout:\n\u0026hellip;and here is the finished panel with all the components mounted:\n","permalink":"http://example.org/modular_synth/buffered_multiple_4x3/","summary":"Abstract A simple 4x3 buffered multiple which can easily be fit on a 46x16 stripboard. The schematics are based on the 1161 Buffered Multiple from Sam Battle (aka LOOK MUM NO COMPUTER).\nIntroduction Alright, this is a very simple yet absolutely essential module in a modular synth: the buffered multiple.\nWhy is it called multiple? Because it\u0026rsquo;s makes multiple signals out of one by replicating it. What does buffered mean? In contrast to a passive multiple which is basically a cable distributor, a buffered multiple not only replicates the signal on each of its outputs, it also buffers them in the sense that it decouples it from the original current source.","title":"Buffered multiple 4x3"},{"content":"I still manage a few old servers with 3Ware/LSI MegaRAID controllers (e.g. the 9650SE) and wrote the following Python3 script which is sitting in /etc/cron.daily and sends and email if there is any problem with the battery, disks or units. Keep in mind that scripts inside the /etc/cron.* folders are not allowed to have a dot in the filename, otherwise those will be ignored.\nIf you don\u0026rsquo;t have a working mail configuration, I recommend exim4 which is easily set up in a few minutes with standard settings.\nHere is the script, make sure to change the TW_CLI_CMD, CONTROLLER and ALERT_MAIL and of course feel free to copy transform and combine.\n#!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; Monitoring and mail alert for LSI/3Ware RAID systems, like the 9650SE. Author: Tamas Gal Email: tamas.gal@fau.de Date: 2021-03-25 \u0026#34;\u0026#34;\u0026#34; import re import smtplib import socket import subprocess TW_CLI_CMD = \u0026#34;/usr/sbin/tw_cli\u0026#34; CONTROLLER = \u0026#34;c0\u0026#34; ALERT_MAIL = \u0026#34;...\u0026#34; def check_units(stdout): \u0026#34;\u0026#34;\u0026#34;Check all RAID units and return True if they are OK\u0026#34;\u0026#34;\u0026#34; units_status = re.search(r\u0026#39;\\nu\\d+\\s+[^ ]+\\s+([^ ]+)\u0026#39;, stdout).groups() return all(s == \u0026#34;OK\u0026#34; for s in units_status) def check_disks(stdout): \u0026#34;\u0026#34;\u0026#34;Check all disks and return True if they are OK\u0026#34;\u0026#34;\u0026#34; disks_status = re.search(r\u0026#39;\\np\\d+\\s+([^ ]+)\u0026#39;, stdout).groups() return all(s == \u0026#34;OK\u0026#34; for s in disks_status) def check_battery(stdout): \u0026#34;\u0026#34;\u0026#34;Check the battery and return True if it\u0026#39;s OK\u0026#34;\u0026#34;\u0026#34; battery_status = re.search(r\u0026#39;\\nbbu\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\\s+([^\\s]+)\u0026#39;, stdout).groups() return battery_status == (\u0026#39;On\u0026#39;, \u0026#39;Yes\u0026#39;, \u0026#39;OK\u0026#39;, \u0026#39;OK\u0026#39;, \u0026#39;OK\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: process = subprocess.Popen( [TW_CLI_CMD, f\u0026#34;/{CONTROLLER}\u0026#34;, \u0026#34;show\u0026#34;], stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr = [s.decode() for s in process.communicate()] alert_messages = [] if not check_units(stdout): alert_messages.append(\u0026#34;Not all units are OK\u0026#34;) if not check_disks(stdout): alert_messages.append(\u0026#34;Not all disks are OK\u0026#34;) if not check_battery(stdout): alert_messages.append(\u0026#34;Battery is not OK\u0026#34;) if stderr: alert_messages.append(f\u0026#34;STDERR:\\n{stderr}\u0026#34;) if alert_messages: hostname = socket.gethostbyaddr(socket.gethostname())[0] sender = \u0026#34;root@\u0026#34; + hostname subject = \u0026#39;RAID alert!\u0026#39; message = f\u0026#34;From: \u0026lt;{sender}\u0026gt;\\nTo: {ALERT_MAIL}\\nSubject: {subject}\\n\u0026#34; message += \u0026#34;\\n\\n\u0026#34;.join(alert_messages) message += f\u0026#34;\\n\\nRAID status:\\n{stdout}\u0026#34; smtplib.SMTP(\u0026#39;localhost\u0026#39;).sendmail(sender, ALERT_MAIL, message) exit(1) ","permalink":"http://example.org/raid-monitor/","summary":"I still manage a few old servers with 3Ware/LSI MegaRAID controllers (e.g. the 9650SE) and wrote the following Python3 script which is sitting in /etc/cron.daily and sends and email if there is any problem with the battery, disks or units. Keep in mind that scripts inside the /etc/cron.* folders are not allowed to have a dot in the filename, otherwise those will be ignored.\nIf you don\u0026rsquo;t have a working mail configuration, I recommend exim4 which is easily set up in a few minutes with standard settings.","title":"RAID Monitor for LSI/3Ware MegaRAID controllers"},{"content":"  Diese App widme ich meiner Freundin Sarah ;-)\nDownload im macOS App Store\nSie ist kostenlos und streamt alle Antenne Bayern Sender – von Chillout über Schlager bis Kids für Hits – direkt auf den Mac (ohne Flashplayer oder iTunes). Außerdem zeigt sie den Interpreten und Songtitel des zuletzt gespielten Liedes (falls möglich).\nAchja, sie ist ordnungsgemäß (via Developer-ID) signiert und Gatekeeper-freundlich ; )\n","permalink":"http://example.org/mac/antenne/","summary":"Diese App widme ich meiner Freundin Sarah ;-)\nDownload im macOS App Store\nSie ist kostenlos und streamt alle Antenne Bayern Sender – von Chillout über Schlager bis Kids für Hits – direkt auf den Mac (ohne Flashplayer oder iTunes). Außerdem zeigt sie den Interpreten und Songtitel des zuletzt gespielten Liedes (falls möglich).\nAchja, sie ist ordnungsgemäß (via Developer-ID) signiert und Gatekeeper-freundlich ; )","title":"Antenne"},{"content":"  ChronoSlider is a tiny tool to help you manage alarms and timers with a unique user interface. It is designed to be simple, seamless and functional.\nAvailable on the macOS App Store\nDefine a global hotkey and set an alarm or timer with only one mouse click! You choose the alarm time and a predefined alarm message with sliding your mouse across the screen.\nCreate your own Chronolings or use the predefined ones to execute timed (and recurring) AppleScript one-liner!\nFeatures  Global Hotkey - access ChronoSlider from anywhere Set an alarm or timer with just two mouse clicks Intuitive and unique user interface Repeating alarms and reminders Execute timed (and recurring) AppleScript commands with your own Chronolings  ChronoSlider Reviews  Lifehacker.com – \u0026ldquo;Chrono Slider is actually a really clever app and definitely worth a look.\u0026rdquo; Appstorm.net – \u0026ldquo;It’s simple enough that you can set a new alarm in just a few seconds, but also useful enough that if you want it to perform something complicated, you can most likely do it through the AppleScripts.\u0026rdquo; One Thing Well – \u0026ldquo;As well as the interesting overlay interface, you can set up ‘chronolings’—AppleScripts triggered by alarms.\u0026rdquo; Minimal Mac – \u0026ldquo;Interesting little menubar tool to manage timers and alarms. Designed to be super simple and functional. I know there are many out there in need of such a tool.\u0026rdquo; Mac360.com – \u0026ldquo;The latest cool little timer to grace my Mac’s screen is ChronoSlider. It lets you set alarms and timers with a couple of mouse clicks. And, it bares an interface that dares to Think Different™.\u0026rdquo; 65BITS – \u0026ldquo;Je ne connais aucun utilitaire qui permet de programmer une alarme aussi vite que ChronoSlider!\u0026rdquo; DigitalLiving.ch – \u0026ldquo;Chronoslider ist eine interessante Ergänzung für das Waffenarsenal, mit dem man seinen Tagesablauf in Schach halten möchte. \u0026quot;  ","permalink":"http://example.org/mac/chronoslider/","summary":"ChronoSlider is a tiny tool to help you manage alarms and timers with a unique user interface. It is designed to be simple, seamless and functional.\nAvailable on the macOS App Store\nDefine a global hotkey and set an alarm or timer with only one mouse click! You choose the alarm time and a predefined alarm message with sliding your mouse across the screen.\nCreate your own Chronolings or use the predefined ones to execute timed (and recurring) AppleScript one-liner!","title":"Chronoslider"},{"content":"Problem to solve Update all packages which are managed by pip.\nFix pip list --outdated --format=freeze | grep -v \u0026#39;^\\-e\u0026#39; | cut -d = -f 1 | xargs -n1 pip install -U Alternatively pip freeze|grep \u0026#39;==\u0026#39;|awk -F= \u0026#39;{print $1}\u0026#39; | xargs pip install -U ","permalink":"http://example.org/pip-upgrade-all/","summary":"Problem to solve Update all packages which are managed by pip.\nFix pip list --outdated --format=freeze | grep -v \u0026#39;^\\-e\u0026#39; | cut -d = -f 1 | xargs -n1 pip install -U Alternatively pip freeze|grep \u0026#39;==\u0026#39;|awk -F= \u0026#39;{print $1}\u0026#39; | xargs pip install -U ","title":"pip update-all"},{"content":"Symptoms You try to attach to or create a new tmux session and you get the following error message:\nopen terminal failed: missing or unsuitable terminal: st-256color Fix Copy over your terminfo definition with this one-liner:\ninfocmp st-256color|ssh USER@TARGETHOST \u0026#34;mkdir -p .terminfo \u0026amp;\u0026amp; cat \u0026gt;/tmp/ti \u0026amp;\u0026amp; tic /tmp/ti\u0026#34; That\u0026rsquo;s it\u0026hellip;\n","permalink":"http://example.org/st_termcap/","summary":"Symptoms You try to attach to or create a new tmux session and you get the following error message:\nopen terminal failed: missing or unsuitable terminal: st-256color Fix Copy over your terminfo definition with this one-liner:\ninfocmp st-256color|ssh USER@TARGETHOST \u0026#34;mkdir -p .terminfo \u0026amp;\u0026amp; cat \u0026gt;/tmp/ti \u0026amp;\u0026amp; tic /tmp/ti\u0026#34; That\u0026rsquo;s it\u0026hellip;","title":"st terminal support in tmux"},{"content":"Installing protobuf The first step is of course installing the protobuf library. I used homebrew for the main library and pip to install the Python modules:\nbrew install protobuf pip install protobuf Then I defined a very simple data structure using the proto-syntax:\n// Filename: foo.proto  package prototest; message Foo { required int32 id = 1; required string bar = 2; optional string baz = 3; } This proto-file can now be translated into C++ and Python classes via:\nprotoc foo.proto –cpp_out=. –python_out=. The folder should now contain the C++ header and source files and the Python code:\n├── foo.pb.cc ├── foo.pb.h ├── foo.proto └── foo_pb2.py Let’s have a look at the very basic C++ code, which is meant to send an instance of foo over the network, using UDP (to localhost on port 5555):\n// Filename: send.cc  #include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt; // this is our proto of foo #include \u0026#34;foo.pb.h\u0026#34; int main(int argc, char **argv) { struct sockaddr_in addr; addr.sin_family = AF_INET; inet_aton(\u0026#34;127.0.0.1\u0026#34;, \u0026amp;addr.sin_addr); addr.sin_port = htons(5555); // initialise a foo and set some properties  GOOGLE_PROTOBUF_VERIFY_VERSION; prototest::Foo foo; foo.set_id(4); foo.set_bar(\u0026#34;narf\u0026#34;); // serialise to string, this one is obvious ; )  std::string buf; foo.SerializeToString(\u0026amp;buf); int sock = socket(PF_INET, SOCK_DGRAM, 0); sendto(sock, buf.data(), strlen(buf.c_str()), 0, (struct sockaddr *)\u0026amp;addr, sizeof(addr)); return 0; } I compiled it via clang++:\nclang++ -o send send.cc foo.pb.cc -lprotobuf And finally, this is the Python code, which waits for UDP packets and deserialise them into foo. Again: no error checking whatsoever, this is only to demonstrate the functionality:\n# Filename: receive.py import socket from foo_pb2 import Foo sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) sock.bind((\u0026#34;127.0.0.1\u0026#34;, 5555)) foo = Foo() while True: data, addr = sock.recvfrom(1024) foo.ParseFromString(data) print(\u0026#34;Got foo with id={0}and bar={1}\u0026#34;.format(foo.id, foo.bar)) Now we’re done and this is the final directory structure:\n├── foo.pb.cc ├── foo.pb.h ├── foo.proto ├── foo_pb2.py ├── receive.py ├── send └── send.cc To test the script, simply run receive.py to listen to UDP packets via\npython receive.py and keep your eyes on the output when you execute the C++ generated send script:\n./send ","permalink":"http://example.org/protobuf/","summary":"Installing protobuf The first step is of course installing the protobuf library. I used homebrew for the main library and pip to install the Python modules:\nbrew install protobuf pip install protobuf Then I defined a very simple data structure using the proto-syntax:\n// Filename: foo.proto  package prototest; message Foo { required int32 id = 1; required string bar = 2; optional string baz = 3; } This proto-file can now be translated into C++ and Python classes via:","title":"Data Exchange Between Python and C++ via protobuf"}]